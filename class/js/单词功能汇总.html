<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		let 变量声明
		var 变量声明
		const  常量声明
		function 函数声明
		 fn.apply()//函数方法  apply:方法能劫持另外一个对象的方法，继承另外一个对象的属性.
		  例：function fn() {
				return this.greeting + ', ' + this.name + '!!!';
			}
			let obj = {
				greeting: 'Hello',
				name: 'Rebecca'
			}
			console.log(fn.apply(obj))
		
		undefined 未定义   
		console.log 打印         
		alert()弹出提示 (会阻塞代码)
	    document 文档
		getElementById  以ID的形式获取元素
		getElementsByTagName 以元素标签的形式获取元素 得出的是类数组形式集合(注意：Elements加s)
		getElementsByClassName 以元素class名来获取元素得出(注意：Elements加s)
		querySelector 以ID或class的形式来回去ID（注意：只是静态获取）
		querySelectorAll 以ID、class或者TagName的形式获取一组元素（注意：只是静态获取）
		innerHTML 元素标签内的内容
		innerText 打印标签之间的纯文本信息，会将标签过滤掉，低版本的火狐浏览器不支持，而是支持textContent
		length 长度
		
		el.classList 获取元素身上的所有的className 的列表
		el.classList.add('class') 给元素身上添加class
		el.classList.remove('class')删除元素身上的class
		el.classList.toggle 显示或者隐藏class（toggle切换的意思）
		true 代表真  false 代表假
		if(){}else if(){}else{} 如果...否则如果...否则...
		switch(el){case 1 : break;case 2 : break;} 基于不同的条件来执行不同的动作
		for(循环的初始化条件){添加满足后需要执行的代码}
		while(){}循环
		break 中断结束循环或判断
		continue 跳过向下执行
		数据类型
		Undefined 未定义
		Null 空
		Number 数组类型
		Boolean 布尔
		String  字符串
		Symbol 符号
		--什么时候会出现undefined
	 		1.有变量未赋值
            2.函数默认返回值
            3.某个对象没有这个属性
            4.undefined
            5.没有传入实参
		引用数据类型
		{}object 对象
		[]数组
		typeof 判断数据类型
		Infinity 计算机的最大数值
		-Infinity 计算机的最小数值
		转换数字的三种方法
		Number() 字符串数字转换成数字
		parseInt() 字符串转数字（转换到第一个非数字前面的所有数字，小数点为非数字）*注 第二个参数是表示解析的数字的基数 默认为0 如果它以 “0x” 或 “0X” 开头，将以 16 为基数
		parseFloat()字符串转数字（可转换小数点前后的所有数字）
		要转的数据.toString() 其他数据类型转换成字符串
		什么是真什么是假
		 真:非0,true,非空字符串,非null对象,symbol
    	假:0,false,'',null,NaN,undefined
		函数返回值 return
		arguments 参数（实参的数量集合，只能函数内部使用）
		Array.isArray(要判断的值)判断是否是数组
		Array.from(类数组)类数组转数组
		arr3= [...arr1,...arr2]   ... 扩展运算符 可以将数据（包括数组、类数组、对象）结构展开
		...rest 扩展运算符的反向操作， rest表示参数（只能放在有形参的最后）
		字符串方法
		截取类 
		substr （起始位置,需要截取的长度）返回值为新的字符串
		substring（起始位置,结束位置但不包含结束位置）返回值为新的字符串（如果开始位置>结束位置则两个参数调换位置）
		slice （起始位置,结束位置但不包含结束位置）返回值为新的字符串 例：console.log(str.slice(1, 3));//'bc'
		查询类
		indexOf(指定查询的字符,从哪个位置开始查询)（从前往后查询）返回值为字符的所在位置 如果没有返回-1
		charAt(需要查询字符的索引)返回值查询的对应索引的字符
		lastIndexOf(指定要查询的字符,从哪个位置开始查询)（从后往前查询）返回值为字符串的所在位置，没有返回-1
		includes（需要查询的字符串）返回值 有就返回true 没有返回false
		formCharCode（查询的unicode编码）返回值为对应编码下的字符串
		charCodeAt(需要查询字符的索引)返回值为查询索引对应字符的Unicode编码
		分割类
		split(分割条件)把字符串分割成新的数组 返回值为分割后的数组(分割条件如果为字符串''空则返回值为字符串中所有字母组成的数组)
		转换类
		toUpperCase 把字符串转换为大写
		toLowerCase 把字符串转换为小写
		其他类
		repeat()重复
		trim 去除字符串空白 str.trimLeft()(去掉左边空白)   str.trimRight()(去掉右边的空白)
		
		JSON格式方法
		标准JSON '{"key":"value"}','["key":"value"]'
		         '{"key":number}','["key":number]' //value 是数字类型的可以不用加" "引号
		JSON.parse() （parse解析的意思） 将一个 JSON 字符串转换为对象。 返回值是一个对象
		JSON.stringify 将一个json转换成字符串 
		IE9以下不兼容以上两种方法
		解决方法：1.可以引用josn2.js
		 	   2.或者用eval
		 eval：能够尽可能的把字符串转换成js可执行的代码
		 	*例：eval('alert(1+2)')  会弹出3
		
		对象格式 写法  { key:value}
		
		数组方法
		第一种写法 var arr = new Array("ele","ele",..."ele") 创建一个新数组 
		第二种写法 var arr = ["ele","ele","ele"]; 创建数组的方法
		
		添加删除类
		arr.pop()删除数组最后一位  返回值是最后一个被删除的值
		arr.push(el,el)向数组最后一位添加值或者多个数据 参数为需要添加到数组里的内容  返回值为修改后数组的长度
		arr.shift()删除数组中第一项 返回值为删除的那一位，如果数组为空则返回 undefined
		arr.unshift(el,el)向首位添加一个或者多个值， 返回值是新数组的长度
		arr.concat(el,el,arr1,arr2)将多个数据或者两个或多个数组连接在一起，
		                  例如var a = [1,2,3]; document.write(a.concat(4,5,[6,7]));//输出结果是 [1,2,3,4,5,[6,7]]
            截取类（替换、删除）
    	arr.slice(起始位置下标（包括起始）,结束位置->(不包括结束位置)) 从原数组提取出【起始位置下标开始--结束位置下标结束】的值组成的新的数组，返回值为新数组
    	      *注->1.只传一个参数：只传起始下标 表示原数组从起始下标开始后面的数据全部在内，组成一个新的数组
    	      	  2.两参：返回 起始下标(包括起始),结束下标(不包括结束位置) 组成的新数组
    	      	  3.两参：起始下标(包括起始),结束下标是负数 则负数需要加上数组的长度来替换该位置.
    	      	  4.两参：两个参数都是负数时，所有的都加上数组的长度转换成正数
  	    arr.splice()可以对数组进行 删除、插入、替换  很强大的数组用法 
  	           *注    删除：两参，可以删除任意项，只需要指定2个参数 ，arr.splice(开始位置,要删除的个数) 例如：arr.splice(0,2)第0位开始，删除两个
				        插入:三参，可以向指定位置插入任意数量的项，需要提供3个参数,arr.splice(开始位置,要删除的个数,要插入的值) 
				                    例如：splice(2,0,4,6) 从数组的第2位开始 0为不删除,插入4和6
	                                             替换：三参或多参，可向指定位置 删除 并且插入值，需要提供3或多个参数，arr.splice(开始位置,要删除的个数,要插入的值)
	                                                         例如，splice (2,1,4,6)	从数组第2位开始，删除1个 插入数据4和6
	 拼接类
	 arr.join('拼接符')将数字的值利用指定的连接符拼接在一起，参数如果是空这直接以“ , ”拼接, 原数组不变
	     查询类                                       
       	arr.indexOf(要查找的值,开始查找位置的索引(可选))从前往后查找， 第二个参数 有填写就从参数开始往后查找 ---没参数就从数组的开头开始查找 (返回值为要查找的值在数组中的位置 没有找到返回-1)
       	arr.lastIndexOf(要查找的值,开始查找的索引(可选))从后往前查找 (返回值为要查找的值在数组中的位置 没有找到返回-1)
       	arr.find(function(e,index,all){})查询数组中符合条件的数据，并抠出来 返回值为符合条件的第一个元素的值
       	arr.findIndex(function(e){})在数组中找目标元素，找到就返回目标的索引值，找不到返回-1
       	arr.inclueds(index)利用索引值查找当前数组里是否有这个值， 返回值为布尔着 true或者false
       	   *例：let site = ['runoob', 'google', 'taobao']; site.inclueds('runoob');//返回值  true
       	Array.isArray(arr)判断某个值是否为数组，返回布尔值
             遍历数组类
		arr.forEach(function(e,index,all){  })遍历数组 ,对数组中的每一项运行给定函数,参数分别为e->遍历的内容  index->对应的索引值 all->数组本身。此方法没有返回值
		arr.filter(function(e,index){})数组 过滤 方法 返回值为满足后过滤出来的新数组  比如：let arr2 = arr.filter(e=>e.age>18) 
		arr.map(function(item){})数组映射 对数组的每一项运进行处理(处理条件写在函数里)，返回每次函数调用的结果组成新数组
		    *注->map不会对空数组进行检测 
				map不会改变原始数组 
		arr.sort() 排序，按照升序排列数组中的值，最小值在最前面，最大值在最后面（会改变原数组）
		arr.reverse() 反转数组，可以反转数组项的顺序
		const set = new Set(arr);//数组去重
		arr.reduce(function(x,y){}) 求和/求积/求最大值... 
		   *例： 求和：arr.reduce(function(x,y){return x+y;})
		                     求积：arr.reduce(function(x,y){return x*y;})
		                     求最大值：arr.reduce(function(x,y){return x>y;})
        arr.reduceRight()工作原理同reduce,只是顺序是从数组的右边-->到左边
		arr.fill('替换的值',开始的索引值（可选填）,到数组第几位索引（不包括结束位置）（可选填）) 可选参数不填写默认替换填充全部数组, 
			*注：可选参数只写一位说明 从当前开始后面的值全部填充。
			    可选参数两位都写就按照开始--到数组的第几位结束(不包括结束的值)的位置填充
			*例：var arr = ["Banana", "Orange", "Apple", "Mango","Make"];
				arr.fill("Runoob", 1, 3);//输出结果是["Banana", "Runoob", "Runoob", "Mango","Make"]
		arr.some(function(e,index,arr){})//判断当前数组内的值如果有一个是true的话，且整个数组都为true
			*例：var arr = [1,2,3,4,5,6]  arr.some(function(e,index,arr){return e%2===0;})//true
		arr.every(function(e){})遍历这个数组 判断数组中某个值所有的都为true的时候才会返回true  否则有一个为false都返回是false
		  	*例：var arr = [11,12,13,14]; arr.every(function(e){e > 10; })//true
	数学方法
		Math.min(num1,num2,num3...)用于确定一组数值中的最小值
		Math.max(num1,num2,num3...)用于确定一组数值中的最大值
		Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数；
			*例：alert(Math.ceil(25.9));//26     alert(Math.ceil(25.1)); //26
		Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数；
			*例：alert(Math.floor(25.9));//25     alert(Math.floor(25.1)); //25
		Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数；
			*例：alert(Math.round(25.9));//26     alert(Math.round(25.1)); //25
		Math.random()返回介于0到1之间一个无限不循环小数 如果想大于这个范围的话，不包括0和1,可以套用一下公式：
				*公式：值 = Math.floor(Math.random() * 总数 + 第一个值)
		Math.abs(num) 取出参数的绝对值（绝对值即非负数）把负数转换成正数
	定时器
		setTimeout(callback,time) 在指定时间内，执行一次函数 返回值为一个数字(编号) 会改变js的线程(time->毫秒)
		clearTimeout 清除定时器
		setInterval(callback,time) 一直执行 返回值为number类型（编号）
		clearInterval(定时器的编号) 清除定时器 
		  *注：在定时器中的this指向window
	时间版运动的原来
	     目标点*（已过时间/总共的时间） = 已经走了多少路程
	  已过时间 = 现在时间-刚才时间
	  
	时间对象
	   	Date时间对象用于处理日期和时间
	   	let d = new Date() 用new Date关键字定义时间对象
	   	*注：Date对象自动使用当前的日期和时间作为其初始值
	   	获取时间戳的三种方法（时间戳：返回从 1970 年 1 月 1 日至今的毫秒数）
	   	1.   new Date().getTime()
	   	2.   +new Date
	   	3.   Date.now()
	   	获取日期
	   	let d = new Date();
	   	d.getFullYear()获取 年
	   	d.getMonth()获取 月份 *注：获取当月的月份需要 +1
	   	d.getDate()获取 日 
	   	d.getHours()获取 时
	   	d.getMinutes()获取 分钟
	   	d.getSecounds()获取 秒
	   	d.getDay()获取 周
	   设置日期
	   let d = new Date
	   d.setFullYear() 设置年
	   d.setMonth()设置月 注*设置 Date 对象中月份设置的时候得-1
	   d.setDate()设置日 注* 参数中传0 表示设置的是上个月的最后一天
	   d.setHours()设置小时
		d.setMinutes()设置分钟
		d.setSecounds()设置秒
		d.setDay()设置星期
BOM (browser object model) 浏览器对象模型
	window.open(URL,name,features,replace)//打开新窗口 
		*注： URL：打开的链接地址，
			name：打开的方式 默认新窗口打开（_blank）
			features:新窗口的大小（兼容性极差）
			replace：可选参数 ，布尔值，true - URL 替换浏览历史中的当前条目。false - URL 在浏览历史中创建新的条目。
			注：在高版本浏览器下，如果不是用户主动触发，那么会拦截
	window.close()关闭 window 浏览器窗口
			*注：chrome 调用直接关
				ff：默认不关（当通过open打开的才关闭）
				IE：弹窗询问
				
	screen.height/screen.width 获取屏幕的高度和宽度 
		  *注：加<meta>视口是手机端可视区域尺寸 不加<meta>是整个PC可视区域的尺寸（不计算滚动条）
	screen.availHeight/availWidth 浏览器的屏幕的可用的高度和宽度  
		  *注：加<meta>视口是手机端可视区域尺寸 不加<meta>是整个PC可视区域的尺寸（不计算滚动条）
				
	window.innerWidth / window.innerHeight window下的只读属性，获取浏览器（是pc端可视区）整个可视区的宽度或者高度。
	*注：这里的宽度和高度不包括菜单栏、工具栏以及滚动条等的高度
	document.documentElement.clientWidth 浏览器可视区域（是pc端可视区）宽度
	document.documentElement.clientHeight 浏览器可视区域（是pc端可视区）高度
		*注：计算滚动条的尺寸，滚动条会影响他的尺寸，
			一般有滚动条得出的尺寸要比没滚动条的尺寸大17px，
			菜单栏、工具栏。开发模式控制台同样也会影响他的尺寸
		documentElement可以用body替换，但是要清楚默认样式

	document.body.clientWidth
	document.body.clientHeight
		*注：如果html里的body设置了宽、高则取出的尺寸就是body的设置的尺寸
		 	如果html的body里没有设置宽、高，
		 	计算滚动条的尺寸,滚动条会影响他的尺寸
			 取出的宽度就是可视区的宽度，高度为被html内容所撑开的高度。
	window.pageXOffset/window.pageYOffset 只读属性 设置滚动条向下或者向右滚动
		*注：高版本使用window.scrollTo(x,y) 可写属性
			也可以使用document.documentElement.scrollTop 即可写也可读
		*例：document.documentElement.onclick = function(){
				//获取当前竖滚动条（Y）的位置
				console.log(window.pageYOffset);
				//获取当前竖滚动条（Y）的位置
				console.log(document.documentElement.scrollTop);
				//设置滚动条放回到顶部也就是0的位置
			// document.documentElement.scrollTop = 0;
			//设置滚动条放回到顶部也就是0的位置（第二种写法）
			// window.scrollTo(0,0);
		}
	window.onscroll 滚动监听事件 可监听鼠标中间滚轮的动向
		*例：let num=0;
			 window.onscroll = function(){
			//监听鼠标混轮滚动时，当前滚动条的位置
					console.log(window.pageYOffset);
					num++;
					//统计当前鼠标滚轮滚动了几次
					console.log(num)
				}
	window.onresize 当浏览器窗口缩放时触发的事件
		*例： window.onresize = function(){
				//当window窗口缩放时输出可视区的宽度	
				console.log(window.innerWidth);
				}
location 主要是获取浏览器地址栏的信息
	href :读写地址栏信息（会刷新页面）
	hash：锚信息（不刷新页面）从#号开始的信息
	
	onhashchange()当hash值改变的时候就会触发
	search(查询信息)?xxxxx(会刷新页面)从?到#之间的信息
	正常格式为问号到#号前面，如果?号在#之后，那么全部会认为是锚信息
	http://www.baidu.com?search=miaov#page=3
	服务器环境下才能测试
	localhost -> 域名  相当于baidu 
	localhost:80端口  -> 默认端口号
	host 设置或返回主机名和当前 URL 的端口号
	hostname 设置或返回不带端口号的主机名
	pathname 设置或返回 URL 中的目录 和 文件名
	port 设置或返回当前 URL 的端口号
	protocol 设置或返回当前 URL 的协议(http 或 https)
	reload()  刷新 重新加载当前文档
navigator关于计算机中的信息
	appName 返回浏览器的名称  console.log(navigator.appName)//netscape
	onLine 返回指明系统是否处于脱机模式 返回布尔值 true为联机状态 false为未联机
	platform 返回运行浏览器的操作系统平台（不太精准）
	userAgent 返回由浏览器代理的详细信息(可以用来判断当前访问的是什么系统)
	 *注：信息容易被修改
	 IE:
	  11:
          "Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; rv:11.0) like Gecko"
      10:  "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E)"
	   9:   "Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E)"
	   8:   "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E)"
		判断当前手机访问的是android还是iphone
			function isPhone(){
				let str = navigator.userAgent.toLowerCase();
				if(str.includes('android') || str.includes('iphone') || str.includes('mac')){
					return true;
				}else{
					return false;
				}
			}
history详解：历史记录管理
	在服务器环境下才能运行
	history.length 查看历史记录的长度
	history.back() 退一次；
	history.forward()进一次
	history.go(num) 可以进退 num为多少就进退多少
		*注：正数为进，负数为退
	history.pushState(数据对象,名字,路径) 向浏览器中添加状态
	 	*例：history.pushState({num:1},'hehe','http://localhost:88/2018-4-17/6_history1.html');
		*注：三参：数据对象：一个与指定网址相关的状态对象
				 名字：新页面的标题
				 路径：url 新的网站，必须与当前页面处在同一个域
	history.replaceState(数据对象,名字,路径)替换在状态

	
获取和设置行间属性
	ele.getAttribute('行间属性名')   -> 获取行间属性(如果没有这个属性显示undefined)
		*例：box.getAttribute('style')//可以去到box的行间style的属性
		*注：通过getAttribute()获取到的img的行间属性src是可以用做来做判断条件的路径
	ele.setAttribute('行间属性名','行间属性值') -> 设置行间属性
		*例：box.setAttribute('index','1')//给box设置一个值为2的index行间属性
	ele.removeAttribute('行间属性名') -> 删除行间属性
		*例：box.removeAttribute('style')//删除box的行间属性style
	ele.getBoundingClientRect()//获取当前ele元素的一些属性的集合对象，里面的值参数包括 {top,left,right,bottom,width,height,x,y}
		*注：如果需要取出其中的一个属性值用法：ele.getBoundingClientRect().top
				//这里去到的top值需要清除默认样式才可以用
	ele.offsetTop//获取当前ele到定位父级的top值 
		*注:margin值会影响取出的值尺寸,padding、border值不会影响取出的值
	ele.offsetLeft//获取当前ele的left值
		*注:margin值会影响取出的值尺寸,padding、border值不会影响取出的值
	ele.offsetWidth//获取当前ele的宽
		*注：padding、border值会影响到取出的值，margin值不会影响到取出的值
	ele.offsetHeight//获取当前ele的高
		*注：padding、border值会影响到取出的值，margin值不会影响到取出的值
	---------------------------------------------------------------------------	
		*注：以上offset获取到的元素属性值，如果用都需要清除默认样式
懒加载的原理：
	 1.循环生成li和img 并且给每个img 添加一个假的_src的行间属性并把img真的src的图片路径给这个自定义属性待用
	 2.先获取到当前可视区的高度 let iH = window.innerHeight
	 3.当鼠标滚轮移动时，循环所有的LI判断
	 4.判断 如果第i个LI（也就是进入到可视区的li）的top值小于或者等于可视区范围 就让自定义属性里的假src路径赋值给真src并改变透明度逐渐显示图片

DOM详解（文档对象模型）Document Object Model
		DOM树：一个页面由若干个标签组成的一个树状层级结构
		节点：页面中所有的内容都叫节点。
			<!-- <div> 123456
				...    .
				<!-- 这里是注释 -->
				//
			</div> -->
		要清楚的知道DOM的层级关系
	typeof ele 查看数据类型（方法 || 运算符）
			number 类型的
			string 字符串类型
	ele.nodeType  查看页面节点的类型（属性）
		*注：节点类型：文档节点   document   9   比如->document
					 属性节点   attribute  2    比如->id、style、index 等
					*注：其中ele.attributes可以获取到元素身上所有的属性集合
					*例：box.attributes[0]
					 文本节点    text      3    比如->文字、空格和回车
					 注释节点	 comment   8    比如-><!--这里是注释节点 -->
					 元素节点    element   1    比如->html标签 div、p、h1等
		*例：console.log(document.nodeType)// document的节点类型
	ele.nodeName 查看节点名称
		*例：console.log(box.nodeName)//输出 DIV
	ele.childenodes 获取当前元素下面的所有子节点
	ele.nodeValue 查看节点值
		*例：<div>  
			<!-- {name:注释} -->
		</div>
		console.log(box.childNodes[2].nodeValue)// 输出结果 {name:注释}
	ele.tagName  获取标签元素的名字(获取到的全是大写)
		*例：<p></p>
			console.log(box.childnodes[0].tagName)  //输出的结果都 P
	
	 
on事件
		事件，是文档或者浏览器窗口发生一些特定交互的交互瞬间。 
		js可以侦听这些交互，在交互发生时执行相应的一些代码
		
		onclick 			 鼠标双击
		onmouseover			 鼠标移入
		onmouseout 			鼠标移出
		onmousedown			鼠标按下事件
		onmouseup			鼠标抬起事件
		onmosemove			鼠标移动事件
		onmousewheel/DOMMouseScroll			鼠标滚轮事件
				*注：onmousewheel：详情见课件搜索
		onchange			改变域中事件
		onsubmit			提交按钮被点击事件
		oninput				当value发生变化的时候不用失焦就直接触发
		onfocus				聚焦（蓝亮）
		onblur				失焦（默认的）

		onscroll 			元素滚动条在滚动时触发
		onresize 			浏览器被重置大小时候触发
		onhashchange 		锚信息事件
		onpopstate 			回退函数	window.onpopstate是popstate事件在window对象上的事件,激活状态的历史记录条目发生变化时
		onchange 			--当表单元素内容改变的时候触发的事件 
		ondblclick 			--双击
		键盘事件：
		onkeydown			键盘按下事件
		onkeyup				键盘抬起事件
		移动端事件：		
		ontouchstart 		手指按下		侦听手指在手机屏幕上按下
		ontouchmove			手指移动		侦听手指在手机屏幕上移动
		ontouchend			手指抬起		侦听手指在手机屏幕上抬起


		当用户操作浏览器页面的时候，会触发各种事件,这个时候如果 
		对应的事件有绑定事件函数，那么就触发 
		用户是被监听者 
		浏览器是监听者

		事件是元素本身自带的一个属性
		<button id="btn">按钮</button>
		console.dir(btn.onclick);
事件绑定和（解除绑定）
		事件绑定分三种
		1.嵌入DOM
		2.直接绑定事件（也就是传统的on事件）
				 给某个元素绑多个事件前后会覆盖,触发的时候只会执行一次
		*例：btn.onclick = function(){
            alert(1);
            //on事件解除绑定可直接onclick=null;
            btn.onclick = null;
				}
		3.事件监听addEventListener()//可给同一个元素添加多次事件,不会被覆盖 
			*注：给某个元素绑多个事件,触发的时候会执行绑定的次数 
				移动端都要用事件绑定的形式去绑定事件函数。不可以用on事件
		addEventListener(不带on的事件名,事件函数,是否捕获默认为false)	
		removeEventListener()//解除点击事件 
			*注：匿名函数不能从根源上解除绑定
	事件冒泡（子级事件源到父级）
			事件冒泡：当触发某个元素事件时,如果自己及祖先节点都绑定了同样的事件函数,那么会从下而上依次出发，直到window结束，这个过程叫冒泡过程 
			从下而上依次出发同一个事件，直到window结束叫冒泡
				*注：在同一个函数绑定的时候，前者覆盖后者
	事件捕获（父级到子级事件源）
			传统的事件绑定是不能监听到捕获. 
			on事件没有捕获只有冒泡 
			只有addEventListener才能监听捕获状态. 
			捕获：自上而下window起到目标过程
	事件流（事件模型）一共分3个阶段(先捕获再冒泡)
			捕获阶段-->目标节点-->冒泡阶段 
			正常顺序是先捕获再冒泡（到达目标点事件源节点代码写的顺序是一样的例如：先写冒泡就先出冒泡）
	解决冒泡问题
			阻止冒泡，其实是子孙级触发，不让祖先级触发，所以阻止冒泡要从源头下手（子孙级【目标阶段】）
	传统的事件阻止冒泡
		ev.cancelBubble = true;//不标准（但是所以浏览器都支持）
		ev.stopPropagation();//是标准（但是不是所有浏览器都支持）
	事件对象 event
			当用户操作页面的时候，事件函数的第一个参数会记录下用户本次操作的细节信息.
			*例：document.onclick = function(ev){
				console.log(ev.clientX);//可打印每次鼠标点击点的坐标位置
			   }
on的ev.事件获取
		ev.type			获取点击事件的类型		返回事件类型比如：click,onmousedown
		ev.target		获取事件源				返回值为当前元素例如：课件搜索target有示例
		ev.pageX/ev.pageY		获取当前事件横/纵向轴坐标 		
		ev.screenX/ev.screenY		鼠标指针相对于显示器左上角的位置
		ev.clientX/ev.clientY		鼠标指针相对于可视窗口左上角的位置
		ev.offsetX/ev.offsetY		事件发生时鼠标距离事件源左上角的距离
		ev.button					获取鼠标按键（左键,右键,滚轮）  		返回值：0为左键 1为滚轮 2为右键
		ev.altKey/ev.shiftKey/ev.ctrlKey		键盘双击键 		返回布尔值
		ev.keyCode					键盘onkeydown/onkeyup事键盘的键值			返回值：Unicode字符 比如回车：13
		ev.code			侦听键盘按键的键值			返回值：上：ArrowUp 下：ArrowDown 左：ArrowLeft 右：ArrowRight
		移动端ev事件	
		ev.touches		当前在屏幕上的手指列表数 		表示当前跟踪的触摸操作的touch对象的数组。
		ev.targetTouches		当前在元素上的手指列表数			特定于事件目标的Touch对象的数组
		ev.changedTouches		触发当前事件的手指列表			表示自上次触摸以来发生了什么改变的Touch对象的数组。
		ev.identifier			标识触摸的唯一ID
		


		
		
	git流程和命令大全
		git版本控制工具（不用网络就可以进行版本控制）
		github是代码托管、参与协作、交友的网站
	git 分布式
	首先建立github账号
		先去 https://github.com/ 去申请自己的github账号 
	
	安装git 
		https://git-scm.com/ 下载git并按照提示安装
	安装好git后
	1.创建key ssh密钥
		

	mongodb使用方法：
	1.	需要安装node / mongoDB    https://www.mongodb.com/ 安装
	启动数据库:
		找到D:\MongoDB\Server\3.6\bin  shift + 右键单击-> 在此处打开窗口
		.\mongod --dbpath=数据库存放的位置 --port=27017 
	2.	使用npm install 安装依赖项
	3.	npm run dev  运行服务
	4.	在http://localhost:88 访问
	
	npm i nrm -g
	nrm test  查看哪个速度快
	nrm use cnpm  切换镜像
	
		
		
		> ajax:
		Asynchronous JavaScript And XML 异步 JS 和 XML
		启动服务器步骤：
		Shift+鼠标右键  打开 命令窗口
		1.  npm i  安装node_modules
		2. 	npm start  启动服务
		
		老版本from 请求接口步骤
		get  接口
		method 请求的方式
		name：user || pass
	ajax原理：
	
	ajax中get请求和post请求的区别
		get请求相对来说不安全
		get请求是会将参数跟在URL后进行传递，
		get请求体积小，提交的数据最多只能是1024字节
		get请求url如果遇到中文，在IE下是不兼容的，中文url需要利用encodeURI()转码
		* 注 例如：ajax.open('get','/get?user='+encodeURI(input.value));
		post请求相对来说安全
		post体积大
		post需要设置请求头，ajax.setRequestHeader('Content-type','application/x-www-form-urlencoded')
	
	//get请求方式写法
		new XMLHttpRequest //创建XMLHttpRequest对象语句，XMLHttpRequest对象是于后端与服务器交换数据
		ajax.open('get',get?url+'sj=',true) //设置请求方式和链接服务器
		*注 加sj字符主要是为了考虑服务器缓存
		ajax.send()//发送请求
		//输出结果方法可用两种方式一种是onload事件
		
		ajax.onload= function(){
			console.log(ajax.responseText)//接收返回值
		}
		另外一种是onreadystatechange事件
		其中有个readyState属性 参数
	readyState：请求状态，返回的是整数（0-4）。
		0（未初始化）：还没有调用 open() 方法。（拿不到）
		1（载入）：已调用 send() 方法，正在发送请求。（如果想拿到1的结果需要1和4调换）
		2（载入完成）：send() 方法完成，已收到全部响应内容。
		3（解析）：正在解析响应内容。
		4（完成）：响应内容解析完成，可以在客户端调用。
		ajax.onreadystatechange = function(){//请求完成后触发onreadystatechange
			//当readyState为4的时候边上请求完成并响应内容解析完成可以调用
			if(ajax.readyState ==4){
				console.log(ajax.responseText)
			}
			
		}
	http状态码 用ajax.status状态码获取
                1,2,3,4,5,6开头的编码
                1开头，消息类
                200   200-207成功
                304,302 重定向  302也算成功
                404  请求错误
                5-6  服务器错误
		
		//post请求写法
		const ajax = new XMLHttpRequest()
		ajax.open('post',url)
		//设置请求头
		ajax.setRequestHeader('Content-tyep','application/x-www-form-urlencoded')
		ajax.send('url'+value)//通过服务器发生的方式给服务传输数据
		
		
		
		
		
		__proto__原型链
		
		实例化对象的原型链 === 构造函数的原型
		
		函数有原型而且有原型链
		对象只有原型链，没有原型
		
		
		
		
		构造函数的原型下的属性或者方法，只给他的实例化对象用
		
		
		
	React组件的生命周期
			组件的生命周期可分成三个状态：
					Mounting：已插入真实 DOM（只会执行一次）

							constructor//只执行一次
							componentWillMount()一上来新执行
							componentDidMount()第一次渲染后调用

					Updating：正在被重新渲染

							componentWillReceiveProps()父级数据更新后被调用，这个方法在初始化render时不会被调用
							shouldComponentUpdate(newProps,newState)主要做性能优化,比较子级数据和父级数据，
											return true的时候表示子级组件数据更新时也同时更新父级数据
											return false的时候表示子级组件数据更新时不同时更新父级数据
									*注：两参

					Unmounting：已移出真实 DOM
							componentDidMount()
			
			componentWillUnmount()组件移除的时候立刻被调用，一般在切换路由的时候干的事
			
		
		
		
		
		
		
		
		
		
		
		
		
		
		focus() 文本框聚焦
		
		
		
		
		
		
	</body>
</html>
